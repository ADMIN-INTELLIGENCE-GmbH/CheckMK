#!/bin/bash
############################################################
#    _   ___  __  __ ___ _  _                              #
#   /_\ |   \|  \/  |_ _| \| |                             #
#  / _ \| |) | |\/| || || .` |                             #
# /_/ \_\___/|_|  |_|___|_|\_|                             #
#  ___ _  _ _____ ___ _    _    ___ ___ ___ _  _  ___ ___  #
# |_ _| \| |_   _| __| |  | |  |_ _/ __| __| \| |/ __| __| #
#  | || .` | | | | _|| |__| |__ | | (_ | _|| .` | (__| _|  #
# |___|_|\_| |_| |___|____|____|___\___|___|_|\_|\___|___| #
#   ___       _    _  _                                    #
#  / __|_ __ | |__| || |                                   #
# | (_ | '  \| '_ \ __ |                                   #
#  \___|_|_|_|_.__/_||_|                                   #
#                                                          #
############################################################
############################################################
# Borg backup check for Checkmk (Local Check)
# Returns status + list of all backups with timestamps + size info
############################################################
# Author: Sascha Jelinek
# Company: ADMIN INTELLIGENCE GmbH
# Date: 2026-01-14
# Version: 2.5.1
# Web: www.admin-intelligence.de
############################################################

STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3

debug(){   ([ "${verbose}" -gt 1 ] && echo "$*" >&2) || return 0; }
verbose(){ ([ "${verbose}" -gt 0 ] && echo "$*" >&2) || return 0; }

check_name() {
    echo "BORG: ${HOST:-$(echo "$BORG_REPO" | grep -oP 'backup/\K[^/"]+')}"
}

check_running_processes() {
    # Prüfen ob borg_backup.sh läuft
    backup_pid=$(pgrep -f "borg_backup.sh" | head -n1)
    if [ -n "$backup_pid" ]; then
        # Prozess-Startzeit in Sekunden seit Epoch auslesen
        start_epoch=$(ps -p "$backup_pid" -o lstart= | xargs -I{} date -d "{}" +%s)
        now_epoch=$(date +%s)
        runtime_sec=$(( now_epoch - start_epoch ))

        # Laufzeit in Stunden und Minuten umrechnen
        hours=$(( runtime_sec / 3600 ))
        mins=$(( (runtime_sec % 3600) / 60 ))

        # Schwellwerte prüfen (neu: CRIT bei >=24h)
        if [ $runtime_sec -ge 86400 ]; then  # 24h = 86400 Sekunden
            state=$STATE_CRITICAL
            msg="CRITICAL - borg_backup.sh running for ${hours}h ${mins}m (too long >24h), please check!"
        elif [ $hours -ge 4 ]; then
            state=$STATE_WARNING
            msg="WARNING - borg_backup.sh running for ${hours}h ${mins}m, still running... please stand by."
        else
            state=$STATE_OK
            msg="borg_backup.sh running for ${hours}h ${mins}m, please stand by. Elevator music is playing until then :-)"
        fi

        echo "${state} \"$(check_name)\" - $msg"
        exit $state
    fi

    # Prüfen ob /usr/bin/borg compact läuft und Laufzeit ermitteln
    compact_pid=$(pgrep -f "/usr/bin/borg compact" | head -n1)
    if [ -n "$compact_pid" ]; then
        # Prozess-Startzeit in Sekunden seit Epoch auslesen
        start_epoch=$(ps -p "$compact_pid" -o lstart= | xargs -I{} date -d "{}" +%s)
        now_epoch=$(date +%s)
        runtime_sec=$(( now_epoch - start_epoch ))

        # Laufzeit in Stunden und Minuten umrechnen
        hours=$(( runtime_sec / 3600 ))
        mins=$(( (runtime_sec % 3600) / 60 ))

        # Schwellwert prüfen
        if [ $hours -ge 8 ]; then
            state=$STATE_CRITICAL
            msg="CRITICAL - Repository compacting for ${hours}h ${mins}m, running too long, please check!"
        elif [ $hours -ge 4 ]; then
            state=$STATE_WARNING
            msg="WARNING - Repository compacting for ${hours}h ${mins}m, still running... please stand by."
        else
            state=$STATE_OK
            msg="Repository compacting for ${hours}h ${mins}m, please stand by. Elevator music is playing until then :-)"
        fi

        echo "${state} \"$(check_name)\" - $msg"
        exit $state
    fi
}

check_nextcloud_datadirectory() {
    local nc_configs=()
    local data_dir=""
    local backup_paths_array=()
    local mountpoint_path=""
    
    # Nextcloud DataDir finden
    mapfile -t nc_configs < <(find /var/www /srv /opt -maxdepth 4 -type f -name "config.php" 2>/dev/null | head -5)
    
    for nc_config in "${nc_configs[@]}"; do
        if grep -q "'datadirectory'" "$nc_config" 2>/dev/null && \
           grep -q "'instanceid'" "$nc_config" 2>/dev/null; then
            
            data_dir=$(grep "'datadirectory'" "$nc_config" 2>/dev/null | \
                       head -1 | sed -n "s/.*['\"]\([^'\" ]*\)['\"].*/\1/p")
            [ -n "$data_dir" ] && break
        fi
    done
    
    [ -z "$data_dir" ] && return 0
    
    # MOUNTPOINT des DataDir finden
    if mountpoint "$data_dir" >/dev/null 2>&1; then
        mountpoint_path="$data_dir"
    elif mountpoint "$(dirname "$data_dir")" >/dev/null 2>&1; then
        mountpoint_path="$(dirname "$data_dir")"
    fi
    
    # BACKUP_PATHS Array
    IFS=' ' read -ra backup_paths_array <<< "$BACKUP_PATHS"
    
    for backup_path in "${backup_paths_array[@]}"; do
        # 1. Exakter Match
        if [ "$backup_path" = "$data_dir" ]; then
            return 0
        fi
        
        # 2. Mountpoint exakt gesichert
        if [ -n "$mountpoint_path" ] && [ "$backup_path" = "$mountpoint_path" ]; then
            return 0
        fi
        
        # 3. /var/www/ deckt ab (nur wenn KEIN Mountpoint)
        if [ -z "$mountpoint_path" ] && [[ "$backup_path" == "/var/www" ]] && [[ "$data_dir" == "/var/www/"* ]]; then
            return 0
        fi
    done
    
    echo "${STATE_CRITICAL} \"$(check_name)\" - CRITICAL - Nextcloud DataDir '$data_dir' $([ -n "$mountpoint_path" ] && echo "(Mountpoint: $mountpoint_path)") NOT in BORG config!"
    exit $STATE_CRITICAL
}

error() {
    msg="$*"

    if [[ "$msg" =~ "Failed to create/acquire the lock" ]] && [[ "$msg" =~ "timeout" ]]; then
        running=$(pgrep -f "borg create")
        if [ -n "$running" ]; then
            echo "${STATE_OK} \"$(check_name)\" - Backup running... please stand by. Elevator music is playing until then :-)"
            exit "${STATE_OK}"
        else
            echo "${STATE_CRITICAL} \"$(check_name)\" - lock exists, but no active backup found! (Error: $msg)"
            exit "${STATE_CRITICAL}"
        fi
    fi

    if [[ "$msg" =~ "Borg nicht installiert" ]] || \
       [[ "$msg" =~ "passphrase supplied in BORG_PASSPHRASE" ]] || \
       [[ "$msg" =~ "does not exist" ]]
    then
        echo "${STATE_WARNING} \"$(check_name)\" - BORG warning: $msg"
        exit "${STATE_WARNING}"
    else
        echo "${STATE_UNKNOWN} \"$(check_name)\" - BORG error: $msg"
        exit "${STATE_UNKNOWN}"
    fi
}

warn() {
    echo "${STATE_WARNING} \"$(check_name)\" - BORG warning: not set up correctly: $*"
    exit "${STATE_WARNING}"
}

crit='3 days ago'
warn='28 hours ago'
verbose=0

: "${BORG:=borg}"
if ! command -v "${BORG}" >/dev/null 2>&1; then
    echo "${STATE_WARNING} \"$(check_name)\" - \"borg\" command not found / not installed"
    exit "${STATE_WARNING}"
fi

: "${DATE:=date}"
if ! command -v "${DATE}" >/dev/null 2>&1; then
    echo "${STATE_WARNING} \"$(check_name)\" - \"date\" command not found"
    exit "${STATE_WARNING}"
fi

sec_warn="$(${DATE} --date="${warn}" '+%s')"
sec_crit="$(${DATE} --date="${crit}" '+%s')"
[ ${sec_crit} -gt ${sec_warn} ] && error "Warn must be newer than Crit"

check_logfile_warnings() {
    # Prüfe erst /sicherung, dann /backup auf das Logfile
    local logfile=""
    if [ -f "/sicherung/borg_backup.log" ]; then
        logfile="/sicherung/borg_backup.log"
    elif [ -f "/backup/borg_backup.log" ]; then
        logfile="/backup/borg_backup.log"
    else
        return 0
    fi

    # Suche alle Zeilen mit dem stat: [Errno 2] Fehler
    # Beispiel-Zeile: /blubber: stat: [Errno 2] No such file or directory: '/blubber'/BinaryOp/Pow.php
    mapfile -t error_lines < <(grep -E "stat: \[Errno 2\] No such file or directory:" "$logfile")

    if [ "${#error_lines[@]}" -eq 0 ]; then
        # Keine Fehler gefunden
        return 0
    fi

    # Extrahiere die Verzeichnisse, die betroffen sind
    declare -A missing_dirs_map=()
    for line in "${error_lines[@]}"; do
        path=$(echo "$line" | sed -n "s/.*No such file or directory: '\([^']*\)'.*/\1/p")
        if [ -n "$path" ]; then
            missing_dirs_map["$path"]=1
        else
            dir=$(echo "$line" | sed -E "s|^([^:]+): stat:.*|\1|")
            missing_dirs_map["$dir"]=1
        fi
    done

    # Setze globale Variablen für Ausgabe
    BORG_LOG_WARNING=1
    BORG_LOG_WARNING_DIRS=$(printf "%s\n" "${!missing_dirs_map[@]}" | sort | uniq | tr '\n' ',' | sed 's/,$//')
    return 0
}

extract_backup_paths() {
    local script_file=""
    if [ -f "/sicherung/borg_backup.sh" ]; then
        script_file="/sicherung/borg_backup.sh"
    elif [ -f "/backup/borg_backup.sh" ]; then
        script_file="/backup/borg_backup.sh"
    else
        echo ""
        return 1
    fi

    local borg_command=""
    local line=""

    # 1) Erste NICHT KOMMENTIERTE borg create Zeile + Continuations
    while IFS= read -r line; do
        # Vollständig leere oder kommentierte Zeilen überspringen
        case "$line" in
            ''|[[:space:]]'#'*|'#'*) continue ;;
        esac

        # Falls Zeile nach Trim mit # beginnt → ebenfalls ignorieren
        if [ -n "$(echo "$line" | sed 's/^[[:space:]]*//')" ] &&
           [ "$(echo "$line" | sed 's/^[[:space:]]*//' | cut -c1)" = "#" ]; then
            continue
        fi

        # nur Zeilen mit "borg create"
        case "$line" in
            *"borg "*create*|*borg*' create '*)
                borg_command="$line"
                # Continuations einsammeln
                while [ -n "$borg_command" ] && [ "${borg_command: -1}" = "\\" ]; do
                    borg_command="${borg_command%\\}"
                    IFS= read -r line || break
                    # auch hier: komplett kommentierte Folgezeilen ignorieren
                    case "$line" in
                        ''|[[:space:]]'#'*|'#'*) continue ;;
                    esac
                    borg_command+=" $line"
                done
                break
                ;;
        esac
    done < "$script_file"

    [ -z "$borg_command" ] && echo "" && return 1

    # 2) Pfade extrahieren
    local paths=""
    local word
    for word in $borg_command; do
        # Quotes entfernen
        word=${word%\"}; word=${word#\"}
        word=${word%\'}; word=${word#\'}

        # Optionen/Repo überspringen
        case "$word" in
            --*|*::*) continue ;;
        esac

        # nur absolute Pfade
        case "$word" in
            /*) paths+=" $word" ;;
        esac
    done

    echo "${paths# }"
}

check_for_symlinks() {
    local found_symlink=0
    local symlink_details=""
    for backup_path in $BACKUP_PATHS; do
        if [ -L "$backup_path" ]; then
            found_symlink=1
            target=$(readlink -f "$backup_path")
            symlink_details="${symlink_details}\n - ${backup_path} -> ${target}"
        fi
    done
    if [ $found_symlink -eq 1 ]; then
        echo "${STATE_CRITICAL} \"$(check_name)\" - Symbolic links found in backup paths, see details${symlink_details}"
        exit $STATE_CRITICAL
    fi
}

read_backup_vars() {
    # Versuche zuerst /sicherung, dann /backup zu prüfen
    if [ -f "/sicherung/borg_backup.sh" ]; then
        BACKUP_SCRIPT_VARS="/sicherung/borg_backup.sh"
    elif [ -f "/backup/borg_backup.sh" ]; then
        BACKUP_SCRIPT_VARS="/backup/borg_backup.sh"
    else
        warn "Backup script borg_backup.sh not found in /sicherung or /backup"
    fi

    unset BORG_REPO BORG_PASSPHRASE HOST SUB PHRASE

    while IFS= read -r line; do
        [[ "$line" =~ ^\s*# ]] && continue
        [[ -z "$line" ]] && continue
        for var in HOST SUB PHRASE BORG_REPO BORG_PASSPHRASE; do
            if [[ "$line" =~ ^(export )?$var= ]]; then
                value=$(echo "$line" | sed -E "s/^(export )?$var=['\"]?([^'\"]*)['\"]?/\2/")
                eval "$var=\"$value\""
            fi
        done
    done < "$BACKUP_SCRIPT_VARS"

    [[ "$BORG_REPO" == *"\$HOST"* ]] && [ -n "$HOST" ] && BORG_REPO="${BORG_REPO//\$HOST/$HOST}"
    [[ "$BORG_REPO" == *"\$SUB"* ]]  && [ -n "$SUB" ]  && BORG_REPO="${BORG_REPO//\$SUB/$SUB}"
    [[ "$BORG_PASSPHRASE" == *"\$PHRASE"* ]] && [ -n "$PHRASE" ] && BORG_PASSPHRASE="${BORG_PASSPHRASE//\$PHRASE/$PHRASE}"
    if [ -z "$BORG_PASSPHRASE" ] && [ -n "$PHRASE" ]; then
        BORG_PASSPHRASE="$PHRASE"
    fi

    [ -z "$BORG_REPO" ] && warn "BORG_REPO not found"
    [ -z "$BORG_PASSPHRASE" ] && warn "BORG_PASSPHRASE (or PHRASE) not found"
    export BORG_REPO BORG_PASSPHRASE HOST SUB
}

read_backup_vars
export BORG_REPO BORG_PASSPHRASE
BACKUP_PATHS=$(extract_backup_paths)
check_for_symlinks
check_nextcloud_datadirectory
check_running_processes

last="$(${BORG} list --sort timestamp --last 1 --format '{time}' 2>&1)"
[ $? != 0 ] && error "Borg list failed: ${last}"

num="$(${BORG} list | wc -l)"
[ -z "$last" ] && echo "2 \"$(check_name)\" - CRITICAL - No archive found" && exit $STATE_CRITICAL

sec_last="$(${DATE} --date="${last}" '+%s')"
if [ "${sec_crit}" -gt "${sec_last}" ]; then
    state="${STATE_CRITICAL}"
elif [ "${sec_warn}" -gt "${sec_last}" ]; then
    state="${STATE_WARNING}"
else
    state="${STATE_OK}"
fi

readable_last="$(${DATE} -d "${last}" '+%d.%m.%Y %H:%M')"

# Größe des letzten Backups + Perfdaten

size_info=""
borg_info="$(${BORG} info --last 1 2>/dev/null)"

# Byte-Umrechnung
to_bytes() {
    local num="$1"
    local unit="$2"
    num=$(echo "$num" | sed 's/,/./g')
    unit=$(echo "$unit" | sed 's/[^A-Za-z]//g')
    case "$unit" in
        B)  factor=1 ;;
        kB) factor=1000 ;;
        MB) factor=1000000 ;;
        GB) factor=1000000000 ;;
        TB) factor=1000000000000 ;;
        KiB) factor=1024 ;;
        MiB) factor=$((1024**2)) ;;
        GiB) factor=$((1024**3)) ;;
        TiB) factor=$((1024**4)) ;;
        *)  factor=1 ;;
    esac
    echo $(awk -v n="$num" -v f="$factor" 'BEGIN { printf "%.0f", n*f }')
}

this_original_bytes=""
this_compressed_bytes=""
this_deduplicated_bytes=""
all_original_bytes=""
all_compressed_bytes=""
all_deduplicated_bytes=""

if [ $? -eq 0 ]; then
    this_line=$(echo "$borg_info" | grep "^This archive:")
    all_line=$(echo "$borg_info" | grep "^All archives:")

    if [ -n "$this_line" ]; then
        this_original_val=$(echo "$this_line" | awk '{print $(NF-5)}')
        this_original_unit=$(echo "$this_line" | awk '{print $(NF-4)}')
        this_compressed_val=$(echo "$this_line" | awk '{print $(NF-3)}')
        this_compressed_unit=$(echo "$this_line" | awk '{print $(NF-2)}')
        this_deduplicated_val=$(echo "$this_line" | awk '{print $(NF-1)}')
        this_deduplicated_unit=$(echo "$this_line" | awk '{print $(NF)}')

        this_original_bytes=$(to_bytes "$this_original_val" "$this_original_unit")
        this_compressed_bytes=$(to_bytes "$this_compressed_val" "$this_compressed_unit")
        this_deduplicated_bytes=$(to_bytes "$this_deduplicated_val" "$this_deduplicated_unit")

        size_info=", size: ${this_deduplicated_val} ${this_deduplicated_unit} (dedup), ${this_original_val} ${this_original_unit} (original)"
    fi

    if [ -n "$all_line" ]; then
        all_original_val=$(echo "$all_line" | awk '{print $(NF-5)}')
        all_original_unit=$(echo "$all_line" | awk '{print $(NF-4)}')
        all_compressed_val=$(echo "$all_line" | awk '{print $(NF-3)}')
        all_compressed_unit=$(echo "$all_line" | awk '{print $(NF-2)}')
        all_deduplicated_val=$(echo "$all_line" | awk '{print $(NF-1)}')
        all_deduplicated_unit=$(echo "$all_line" | awk '{print $(NF)}')

        all_original_bytes=$(to_bytes "$all_original_val" "$all_original_unit")
        all_compressed_bytes=$(to_bytes "$all_compressed_val" "$all_compressed_unit")
        all_deduplicated_bytes=$(to_bytes "$all_deduplicated_val" "$all_deduplicated_unit")
    fi
fi

check_logfile_warnings

# Wenn Log-Warnungen gefunden sind, setze Status auf Warn (höher als OK, niedriger als Crit)
if [ "${BORG_LOG_WARNING:-0}" -ne 0 ]; then
    state=$STATE_CRITICAL
    output_text="Backup successful with errors (see details), ${num} backups found, last backup made on ${readable_last}${size_info}"
    error_dirs_details="\nFailed directories:\n"
    IFS=',' read -ra dirs <<< "$BORG_LOG_WARNING_DIRS"
    for dir in "${dirs[@]}"; do
        error_dirs_details+=" - $dir\n"
    done
else
    output_text="${num} backups found, last backup made on ${readable_last}${size_info}"
    error_dirs_details=""  # wichtig, keine Fehlermeldungen anfügen
fi

# output_text="${num} backups found, last backup made on ${readable_last}${size_info}"

# Checkmk Ausgabe
output="${state} \"BORG: ${HOST:-$(echo $BORG_REPO | grep -oP 'backup/\K[^/\"]+')}\""
output+=" number=${num};5:;3:"
output+="|this_original=${this_original_bytes}B;;;;"
output+="|this_compressed=${this_compressed_bytes}B;;;;"
output+="|this_deduplicated=${this_deduplicated_bytes}B;;;;"
output+="|all_original=${all_original_bytes}B;;;;"
output+="|all_compressed=${all_compressed_bytes}B;;;;"
output+="|all_deduplicated=${all_deduplicated_bytes}B;;;;"
output+=" ${output_text}"

backup_lines=""

backups_raw=$(BORG_REPO="$BORG_REPO" BORG_PASSPHRASE="$BORG_PASSPHRASE" ${BORG} list 2>/dev/null)

if [ -n "$backups_raw" ]; then
    while IFS= read -r line; do
        archive_name=$(echo "$line" | awk '{print $1}')
        archive_time=$(echo "$line" | sed -E 's/^[^[:space:]]+[[:space:]]+([^[]+).*/\1/' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        readable_time=$(${DATE} -d "${archive_time}" '+%d.%m.%Y %H:%M' 2>/dev/null)

        if [ -n "$readable_time" ]; then
            backup_lines+="\n - $archive_name (${readable_time})"
        else
            backup_lines+="\n - $archive_name (date unknown)"
        fi
    done <<< "$backups_raw"
else
    backup_lines+="\n (no backups found or access failed)"
fi

# finale Ausgabe zusammenbauen
echo "${output}${error_dirs_details}\nList of all backups:${backup_lines}"