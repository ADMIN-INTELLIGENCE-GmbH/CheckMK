#!/bin/bash
#############################################################
#    _   ___  __  __ ___ _  _                               #
#   /_\ |   \|  \/  |_ _| \| |                              #
#  / _ \| |) | |\/| || || .` |                              #
# /_/ \_\___/|_|  |_|___|_|\_|                              #
#   ___ _  _ _____ ___ _    _    ___ ___ ___ _  _  ___ ___  #
#  |_ _| \| |_   _| __| |  | |  |_ _/ __| __| \| |/ __| __| #
#   | || .` | | | | _|| |__| |__ | | (_ | _|| .` | (__| _|  #
#  |___|_|\_| |_| |___|____|____|___\___|___|_|\_|\___|___| #
#   ___       _    _  _                                     #
#  / __|_ __ | |__| || |                                    #
# | (_ | '  \| '_ \ __ |                                    #
#  \___|_|_|_|_.__/_||_|                                    #
#                                                           #
#############################################################
#############################################################
# Script to check which VM or LXC is not monitored
#############################################################
# Author: Sascha Jelinek
# Company: ADMIN INTELLIGENCE GmbH
# Date: 2025-12-31
# Version: 1.1.0
# Web: www.admin-intelligence.de
#############################################################
# Changelog
# v1.0.1
# - removed low case translation of alias
# v1.0.2
# - added VM-ID to the output
# v1.0.3
# - added grouping by PVE host IP with IP output
# v1.0.4
# - use IP directly from server file without resolution
# v1.0.5
# - single summarized output for all hosts
# v1.0.6
# - total VMs count includes all hosts regardless of monitoring status
# v1.0.7
# - changed wordings
# v1.0.8
# - added comments to each section
# v1.0.9
# - grouped unmonitored VMs output by IP with bullet points
# v1.1.0
# - added LXC container to the output
#############################################################
ok=0
warn=1
crit=2

# Function to append messages to log file with timestamp
log() {
    local msg="$1"
    local timestamp
    timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    echo "[$timestamp] $msg" >> /tmp/checkmk_pve_discovery.log
}

# Get Checkmk site name using omd command, or exit if not found
site=$(omd sites | awk '{print $1}')
if [[ -z "$site" ]]; then
    echo "$warn \"PVE monitored guests\" - No Checkmk site found"
    exit 1
fi

# Path to checkmk livestatus communication socket
livestatus_socket="/opt/omd/sites/$site/tmp/run/live"

# Prefix for switching to Checkmk site context
cmk_prefix="su - $site -c"

# Path to server and blacklist files
server_file="/etc/check_mk/pve_discovery_server.txt"
blacklist_file="/etc/check_mk/pve_discovery_blacklist.txt"

# Declare blacklist mapping associative array
declare -A blacklist_map=()
if [[ -f "$blacklist_file" ]]; then
    while IFS=: read -r host vmid; do
        [[ -z "$host" || -z "$vmid" ]] && continue
        blacklist_map["$host:$vmid"]=1
    done < "$blacklist_file"
fi

# Build host alias mapping from Checkmk site livestatus query
declare -A alias_map=()
while IFS= read -r line; do
    name=${line%%;*}
    alias=${line#*;}
    [[ -z "$alias" ]] && alias="$name"
    [[ -z "$name" ]] && continue
    alias_map["$name"]="${alias}"
done < <($cmk_prefix "echo -e 'GET hosts\nColumns: name alias\nOutputFormat: plain\n' | unixcat $livestatus_socket")

# Read all hosts from server file into array
mapfile -t hosts < "$server_file"

# Initialize VM and LXC tracking variables
declare -A not_monitored_vms_by_ip=()
declare -A total_vm_count_by_ip=()
declare -A not_monitored_lxc_by_ip=()
declare -A total_lxc_count_by_ip=()
total_all_vms=0
total_all_lxc=0

# Iterate over all PVE hosts from server_file
for pve_host in "${hosts[@]}"; do
    pve_host="$(echo -e "${pve_host}" | tr -d '[:space:]')"
    [[ -z "$pve_host" ]] && continue

    # Query all VMs using Proxmox 'qm list' over SSH
    qm_output=$(timeout 10s ssh -o BatchMode=yes -o ConnectTimeout=5 "$pve_host" qm list 2>/dev/null)
    rc=$?
    # If SSH or qm list command fails, warn and continue to next host
    if [[ $rc -ne 0 || -z "$qm_output" ]]; then
        echo "$warn \"PVE monitored guests\" - SSH to $pve_host failed or no qm list output"
        continue
    fi

    # Parse lines with VM data, skipping header
    mapfile -t vm_lines < <(echo "$qm_output" | tail -n +2)

    vm_count_this_host=0

    # Iterate through each VM entry for current host
    for line in "${vm_lines[@]}"; do
        [[ -z "$line" ]] && continue

        # Extract VM ID and name from line
        vmid=$(awk '{print $1}' <<< "$line")
        vmname=$(awk '{print $2}' <<< "$line")

        # Skip VM if it is blacklisted
        if [[ ${blacklist_map["$pve_host:$vmid"]+_} ]]; then
            continue
        fi
        
        ((vm_count_this_host++))

        # Check if VM name is present in alias mapping (i.e., monitored)
        found=0
        for mon_name in "${!alias_map[@]}"; do
            if [[ "${alias_map[$mon_name]}" == "$vmname" ]]; then
                found=1
                break
            fi
        done

        # Add unmonitored VM to tracking map for host IP
        if (( found == 0 )); then
            # Escape parens in VM name for Bash string concatenation
            not_monitored_vms_by_ip["$pve_host"]+="${vmname}_(${vmid}), "
        fi
    done

    # Store VM counts for per-host and total statistics
    total_vm_count_by_ip["$pve_host"]=$vm_count_this_host
    ((total_all_vms+=vm_count_this_host))
    
    # Query all LXC containers using Proxmox 'pct list' over SSH
    pct_output=$(timeout 10s ssh -o BatchMode=yes -o ConnectTimeout=5 "$pve_host" pct list 2>/dev/null)
    rc=$?
    if [[ $rc -ne 0 || -z "$pct_output" ]]; then
        # LXC-Ausfall nur loggen, aber nicht den gesamten Check auf warn setzen
        log "WARN: SSH to $pve_host for pct list failed or no output"
    else
        mapfile -t lxc_lines < <(echo "$pct_output" | tail -n +2)

        lxc_count_this_host=0

        for line in "${lxc_lines[@]}"; do
            [[ -z "$line" ]] && continue

            # pct list: erste Spalte ID, zweite Name
            lxcid=$(awk '{print $1}' <<< "$line")
            lxcname=$(awk '{print $3}' <<< "$line")

            # Skip, wenn in Blacklist (gleiche Datei wiederverwendet)
            if [[ ${blacklist_map["$pve_host:$lxcid"]+_} ]]; then
                continue
            fi

            ((lxc_count_this_host++))

            # Check, ob LXC-Name in alias_map (Monitored)
            found=0
            for mon_name in "${!alias_map[@]}"; do
                if [[ "${alias_map[$mon_name]}" == "$lxcname" ]]; then
                    found=1
                    break
                fi
            done

            # Unmonitored LXC sammeln
            if (( found == 0 )); then
                not_monitored_lxc_by_ip["$pve_host"]+="${lxcname}_(${lxcid}), "
            fi
        done

        total_lxc_count_by_ip["$pve_host"]=$lxc_count_this_host
        ((total_all_lxc+=lxc_count_this_host))
    fi
done

# If all guests (VMs + LXC) are monitored, print success status; otherwise show summary
if (( ${#not_monitored_vms_by_ip[@]} == 0 && ${#not_monitored_lxc_by_ip[@]} == 0 )); then
    total_all_guests=$((total_all_vms + total_all_lxc))
    echo "$ok \"PVE monitored guests\" - All $total_all_guests guests (VMs and LXC) are monitored"
else
    total_unmonitored=0
    unmonitored_list=""
    first_ip=1

    # Build grouped multiline summary of unmonitored VMs and LXC by host IP
    declare -A all_ips=()

    for ip in "${!not_monitored_vms_by_ip[@]}"; do all_ips["$ip"]=1; done
    for ip in "${!not_monitored_lxc_by_ip[@]}"; do all_ips["$ip"]=1; done

    for ip in "${!all_ips[@]}"; do
        vms="${not_monitored_vms_by_ip[$ip]%, }"
        lxc="${not_monitored_lxc_by_ip[$ip]%, }"

        count_vms=0
        count_lxc=0

        if [[ -n "$vms" ]]; then
            count_vms=$(echo -n "$vms" | awk -F', ' '{print NF}')
        fi
        if [[ -n "$lxc" ]]; then
            count_lxc=$(echo -n "$lxc" | awk -F', ' '{print NF}')
        fi

        ((total_unmonitored+=count_vms+count_lxc))

        if (( first_ip == 0 )); then
            unmonitored_list+="\n"
        fi
        first_ip=0

        unmonitored_list+="\n$ip:"

        # VMs als Bulletpoints
        if [[ -n "$vms" ]]; then
            IFS=', ' read -ra vm_array <<< "$vms"
            for vm in "${vm_array[@]}"; do
                vm_clean=$(echo "$vm" | sed 's/^ *//;s/ *$//')
                [[ -z "$vm_clean" ]] && continue
                name_part=${vm_clean%_*}
                id_part=${vm_clean##*_}
                unmonitored_list+="\n- VM ${name_part} ${id_part}"
            done
        fi

        # LXC als Bulletpoints
        if [[ -n "$lxc" ]]; then
            IFS=', ' read -ra lxc_array <<< "$lxc"
            for c in "${lxc_array[@]}"; do
                c_clean=$(echo "$c" | sed 's/^ *//;s/ *$//')
                [[ -z "$c_clean" ]] && continue
                name_part=${c_clean%_*}
                id_part=${c_clean##*_}
                unmonitored_list+="\n- LXC ${name_part} ${id_part}"
            done
        fi
    done

    total_all_guests=$((total_all_vms + total_all_lxc))
    echo "$crit \"PVE monitored guests\" - $total_unmonitored of $total_all_guests guests (VMs and LXC) not monitored, see Details\n$unmonitored_list"
fi
